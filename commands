ssh beelink 'bash -s' << 'EOF'
set -o errexit
set -o nounset
set -o pipefail

PATTERN="${1:-${PATTERN:-}}"
TOP_N=5

say() { printf '%s\n' "$*"; }
warn() { printf 'WARN: %s\n' "$*" >&2; }

# header
say "Process parse test â€” pid, user, %cpu, %mem, cmd"
say "Filter pattern: ${PATTERN:-<none>}"
say "Showing top $TOP_N by CPU and by MEM"

# gather processes using ps (portable-ish)
# ps aux columns: USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
# We will print: PID USER %CPU %MEM COMMAND
ps -eo pid,user,%cpu,%mem,comm --no-headers \
  | awk '{
      pid=$1; user=$2; cpu=$3; mem=$4;
      # put the rest of the command (comm) back together in case it had spaces:
      cmd=$5;
      for (i=6;i<=NF;i++) cmd=cmd" "$i;
      printf("%s\t%s\t%s\t%s\t%s\n", pid, user, cpu, mem, cmd);
    }' \
  > /tmp/process_list.$$ || warn "ps/awk pipeline failed"

# optionally filter (case-insensitive)
if [[ -n "$PATTERN" ]]; then
  grep -i -- "$PATTERN" /tmp/process_list.$$ > /tmp/process_list_filtered.$$ || true
  mv /tmp/process_list_filtered.$$ /tmp/process_list.$$ || true
fi

# print a couple of summaries
say
say "Top $TOP_N by CPU:"
sort -k3 -nr /tmp/process_list.$$ | head -n "$TOP_N" || true

say
say "Top $TOP_N by MEM:"
sort -k4 -nr /tmp/process_list.$$ | head -n "$TOP_N" || true

say
say "Count of matching processes:"
wc -l < /tmp/process_list.$$ || true

# demonstrate reading the file line-by-line and parsing fields
say
say "First $TOP_N lines (parsed in a loop):"
n=0
while IFS=$'\t' read -r pid user cpu mem cmd; do
  n=$((n+1))
  printf "%d) pid=%s user=%s cpu=%s mem=%s cmd=%s\n" "$n" "$pid" "$user" "$cpu" "$mem" "$cmd"
  [[ $n -ge $TOP_N ]] && break
done < /tmp/process_list.$$

# cleanup
rm -f /tmp/process_list.$$ 2>/dev/null || true

say
say "Done."
exit 0
EOF